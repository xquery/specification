<html xmlns="http://www.w3.org/1999/xhtml"><head><title>XProc 2.0: An XML Pipeline Language</title><meta charset="utf-8" /><meta name="generator" content="DocBook XSL 2.0 Stylesheets V2.0.7" /><script type="text/javascript" src="https://docbook.github.com/release/2.0.5/base/js/dbmodnizr.js"></script><link href="prism.css" rel="stylesheet" /><link rel="stylesheet" type="text/css" href="xproc.css" /><link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/base.css" /><link rel="stylesheet" type="text/css" href="base.css" /><link rel="alternate" title="XML" href="xproc20.xml" /><link rel="alternate" title="Latest editor's draft" href="http://www.w3.org/XML/XProc/docs/langspec.html" /><link rel="alternate" title="Latest Public Working Draft" href="http://www.w3.org/TR/xproc/" /></head><body><div class="specification"><div class="head" id="spec.head"><p><a href="http://www.w3.org/"><img height="48" width="72" alt="W3C" src="http://www.w3.org/Icons/w3c_home" /></a></p><h1>XProc 2.0: An XML Pipeline Language</h1><h2>W3C Editor's Draft  <time datetime="2016-03-28T12:47:08Z">28 March 2016 at 12:47 UTC (<a href="https://github.com/xquery/specification/commit/2bd2056a179a58c82a0ef9eddc17c4406113f642">build 1</a>)</time></h2><dl><dt>This Version:</dt><dd><a href="https://xquery.github.io/specification/langspec">https://xquery.github.io/specification/langspec</a></dd><dt>Latest Version:</dt><dd><a href="http://www.w3.org/TR/xproc20/">http://www.w3.org/TR/xproc20/</a></dd><dt>Editors:</dt><dd><span class="personname">Norman Walsh</span>, <span class="orgname">MarkLogic Corporation</span> <code class="email">&lt;<a href="mailto:norman.walsh@marklogic.com">norman.walsh@marklogic.com</a>&gt;</code></dd><dd><span class="personname">Alex Milowski</span>, <span class="orgname">Invited expert</span> <code class="email">&lt;<a href="mailto:alex@milowski.org">alex@milowski.org</a>&gt;</code></dd><dd><span class="personname">Henry S. Thompson</span>, <span class="orgname">University of Edinburgh</span> <code class="email">&lt;<a href="mailto:ht@inf.ed.ac.uk">ht@inf.ed.ac.uk</a>&gt;</code></dd><dt>Repository:</dt><dd><a href="http://github.com/xquery/specification">This specification on GitHub</a></dd><dd><a href="http://github.com/xproc/specification/issues">Report an issue</a></dd><dt>Changes:</dt><dd><a href="diff.html">Diff against current “status quo” draft</a></dd><dd><a href="http://github.com/xquery/specification/commits/">Commits for this specification</a></dd></dl><p>This document is also available in these non-normative formats: <a href="xproc20.xml">XML</a>, 
	  automatic <a href="diff.html">change markup</a> from the previous draft
          courtesy of <a href="http://www.deltaxml.com/">DeltaXML</a>.</p><p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2014 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><hr /><div class="abstract"><h2>Abstract</h2>
<p>This specification describes the syntax and semantics of
<em class="citetitle">XProc 2.0: An XML Pipeline Language</em>, a language for
describing operations to be performed on documents.</p>

<p>An XML Pipeline specifies a sequence of operations to be
performed on documents. Pipelines generally accept
documents as input and produce documents as output.
Pipelines are made up of simple steps which
perform atomic operations on documents and constructs similar to
conditionals, iteration, and exception handlers which control which
steps are executed.</p>
</div><div class="status"><h2>Status of this Document</h2><p><strong>This document is an editor's  draft that has no official standing.</strong></p>

<p><em>This section describes the status of this document at
the time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest revision
of this technical report can be found in the
<a href="http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>

<p>Publication as a First Public Working Draft does not imply
endorsement by the W3C Membership. This is a draft document and may be
updated, replaced or obsoleted by other documents at any time. It is
inappropriate to cite this document as other than work in
progress.
</p>

<p>This document is an editor's draft without normative standing.

</p>

<p>Please report errors in this document by
<a href="https://github.com/xproc/specification/issues">raising
issues</a> on the
<a href="https://github.com/xproc/specification">specification
repository</a>.
Alternatively, you may report errors in this document to the public
mailing list
<a href="mailto:public-xml-processing-model-comments@w3.org">public-xml-processing-model-comments@w3.org</a> (public
<a href="http://lists.w3.org/Archives/Public/public-xml-processing-model-comments/">archives</a> are available).</p>



<p>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
February 2004 W3C Patent Policy</a>. W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/38398/status">public
list of any patent disclosures</a> made in connection with the
deliverables of the group; that page also includes instructions for
disclosing a patent. An individual who has actual knowledge of a
patent which the individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
Claim(s)</a> must disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
6 of the W3C Patent Policy</a>.</p>

<p>This document is governed by the
<a href="http://www.w3.org/2005/10/Process-20051014/" id="w3c_process_revision">14 October 2005 W3C Process Document</a>.</p>
</div></div><hr /><div class="toc"><h2 id="TableOfContents">Table of Contents</h2><ul class="toc"><li><span>1 <a href="#introduction">Introduction</a></span></li><li><span>2 <a href="#terminology">Terminology</a></span></li><li><span>3 <a href="#understanding-xproc">Understanding XProc 2.0</a></span></li><li><span>4 <a href="#step-chains">Step Chains</a></span></li><li><span>5 <a href="#inputs">Inputs</a></span><ul class="toc"><li><span>5.1 <a href="#uri-inputs">URI inputs</a></span></li><li><span>5.2 <a href="#literal-inputs">Literal inputs</a></span></li></ul></li><li><span>6 <a href="#output-bindings">Output bindings</a></span></li><li><span>7 <a href="#step-declarations">Step Declarations and Invocations</a></span></li><li><span>8 <a href="#block_expressions">Block Expressions</a></span></li><li><span>9 <a href="#conditionals">Conditionals</a></span></li><li><span>10 <a href="#variables">Variables</a></span></li><li><span>11 <a href="#projections">Projections</a></span></li><li><span>12 <a href="#iteration">Iteration</a></span></li><li><span>13 <a href="#replacement">Replacement</a></span></li><li><span>14 <a href="#tee">Tee</a></span></li><li><span>15 <a href="#flow-declarations">Flow Declarations</a></span></li><li><span>16 <a href="#xproc-modules">XProc Modules</a></span></li><li><span>A <a href="#grammar">Grammar</a></span></li></ul></div>
  

<section id="introduction" class="section"><h2>1 Introduction</h2>


<p>An XProc Pipeline specifies a set of operations to be
performed on a collection of input documents. Pipelines take documents
as their input and produce documents as their output.</p>

<p>This document introduces an entirely new syntax for XProc:</p>

<div class="itemizedlist">




<ul><li><p>It is a text-based syntax in UTF-8.</p></li><li>
<p>It is in some ways similar to XQuery; parts of the language may
in fact end up being borrowed from or extensions of the XQuery 3.1
grammar.</p>
</li><li>
<p>It is inspired by XProc 1.0; it is attempting to solve the
problems outlined in the requirements document for XProc 2.0.</p>
</li><li>
<p>We are hoping that this design will present fewer and easier
conceptual hurdles than the XML syntax.</p>
</li></ul></div>

<p>XProc remains a data flow language. There are steps, indivisible
black boxes of computation, connected together into a graph. The
connections are the bindings between the output(s) of one step and the
input(s) of another.</p>

<p>Step declarations (see <a href="#step-declarations" title="Step Declarations and Invocations">Section 7, “Step Declarations and Invocations”</a>), resemble function
declarations. The use of a step resembles a function invocation. This
has an important consequence: the inputs and outputs are both named
and ordered. If the declaration for the <code class="step">xslt</code> step has two
inputs, <code class="input">source</code> and <code class="input">stylesheet</code>, declared
in that order, then it is coherent to speak of them both by name and
by ordinal position: the <code class="input">source</code> input is first, the
<code class="input">stylesheet</code> input is second.
</p>
</section>

<section id="terminology" class="section"><h2>2 Terminology</h2>


<p>All of the terminology in this document is subject to revision.
Some of the terms are better and more clearly defined than others. We
present a list of terms here so that you will recognize them when they
first appear. Most are explained in more detail, but in this draft,
not always at the point of first use.</p>

<p>Some terms, such as <code class="port">port</code>, denote the same concept
in XProc 2.0 that they did in XProc 1.0. For conciseness, we use those
terms in this draft without further explanation.
</p>

<div class="glosslist">












<dl><dt id="terminology.4.1" class="glossentry"><em class="glossterm">pipeline</em></dt><dd class="glossdef"><p>A pipeline is a collection operations to be performed on a
set of input documents. Each pipeline consists of <em class="glossterm">steps</em>
and <em class="glossterm">connections</em> between them.
The connections may be strictly linear, they may branch (many steps connected
to the output of a single step), or they may join (a single step connected
to the output of many steps). A pipeline is consequently a directed, acyclic
graph. A pipeline can contain entirely disjoint subgraphs.</p></dd><dt id="terminology.4.2" class="glossentry"><em class="glossterm">step</em></dt><dd class="glossdef"><p>A step is a unit of operation in a pipeline. From the perspective of the
pipeline in which it occurs, it is an atomic operation.
</p></dd><dt id="terminology.4.3" class="glossentry"><em class="glossterm">connection</em></dt><dd class="glossdef"><p>A connection occurs between two steps where the output of one step
is consumed by the input of another. Steps may have zero or more connections,
if they do have connections, they may have one or more connection to any number
of steps.
</p></dd><dt id="terminology.4.4" class="glossentry"><em class="glossterm">flow</em></dt><dd class="glossdef"><p>A flow is a portion of the data flow graph that the pipeline
represents. Writing programs in a text file is inherently linear while
graphs are not. From a graph theoretic perspective, the graph is being
cut into a set of flows. If you don’t have a background in graph
theory, don’t worry about that bit, it’s not important that you
understand it in those terms.
</p></dd><dt id="terminology.4.5" class="glossentry"><em class="glossterm">step chain</em></dt><dd class="glossdef"><p>A step chain is a strictly linear sequence of steps.
Step chains are the most significant unit of work in a pipeline.
Syntactically, a step chain is represented with the arrow
operator (i.e., <span class="symbol">-&gt;</span> or <span class="symbol">→</span>, U+2192).
</p><p>The left hand side of an arrow is always a step or an input binding.
The right hand side of an arrow is always a step, an input binding for
the next step, or a block expression.</p></dd><dt id="terminology.4.6" class="glossentry"><em class="glossterm">input binding</em></dt><dd class="glossdef"><p>Every step has an input binding; it is the set of input ports
from which the step will read to get its input. The simplest input
binding is an item. A binding can be anonymous, in which case it binds
to the first input port, or it can be named, in which case it binds to
the named input port. Assuming that <code class="varname">$in</code> is a
variable bound to a document:</p><div class="itemizedlist">


<ul><li>
<p><code class="code">$in →</code> binds <code class="varname">$in</code> to the first
input of the step on the right hand side of the arrow.</p>
</li><li>
<p><code class="code">source=$in →</code> binds <code class="varname">$in</code> to the
<code class="port">source</code> input of the step on the right hand side of the
arrow.</p>
</li></ul></div><p>If a step has more than one input, the set of inputs is enclosed in
square brackets:</p><div class="itemizedlist">


<ul><li>
<p><code class="code">[$in,$style] →</code> binds <code class="varname">$in</code> to the first input
and <code class="varname">$style</code> to the second
input of the step on the right hand side of the arrow.</p>
</li><li>
<p><code class="code">[source=$in, stylesheet=$style] →</code> binds
<code class="varname">$in</code> to the <code class="port">source</code> input and <code class="varname">$style</code>
to the <code class="port">stylesheet</code> input on the right hand side of the arrow.</p>
</li></ul></div><p>In an input binding, a literal quoted string is interpreted as a
URI reference with the semantic that the URI is dereferenced and the document
returned is used as the input.</p><div class="itemizedlist">

<ul><li>
<p><code class="code">"document.xml" →</code> binds the contents of
<code class="uri">document.xml</code> to the first input of the step on the right
hand side of the arrow.</p>
</li></ul></div></dd><dt id="terminology.4.7" class="glossentry"><em class="glossterm">output binding</em></dt><dd class="glossdef"><p>Steps have outputs that can be accessed by output bindings or
implictly as via ordinal bindings.
</p><p>In an input binding between two steps or a block expression, the
output bindings of the preceding step are accessed ordinally,
<code class="varname">$1</code> is the first output binding,
<code class="varname">$2</code> is the second, etc.
</p><div class="note admonition"><h3>Note</h3><p>At the moment, it isn’t possible to refer to output bindings of the
preceding step by name.</p></div><p>At the end of a step chain, the output binding operator
(<span class="symbol">&gt;&gt;</span> or <span class="symbol">≫</span>, U+226B), assigns
outputs to variables:
</p><div class="itemizedlist">


<ul><li>
<p><code class="code">≫ $out</code> binds <code class="varname">$out</code> to the
document sequence that appears on the first output port of the step it
follows.
</p>
</li><li>
<p><code class="code">≫ result=$out</code> binds <code class="varname">$out</code> to the
<code class="port">result</code> output of the step it follows.</p>
</li></ul></div><p>If a step has more than one output, the set of outputs can be
enclosed in square brackets:</p><div class="itemizedlist">


<ul><li>
<p><code class="code">≫ [$out,$chunks]</code> binds <code class="varname">$out</code> to
the document sequence that appears on the first output port of the
step it follows and <code class="varname">$chunks</code> to the documents that
appear on the second output port.
</p>
</li><li>
<p><code class="code">≫[secondary=$chunks,result=$out]</code> binds
<code class="varname">$out</code> to the documents on the <code class="port">result</code>
output port and <code class="varname">$chunks</code> to the documents on the
<code class="port">secondary</code> output port.
</p>
</li></ul></div></dd><dt id="terminology.4.8" class="glossentry"><em class="glossterm">variables</em></dt><dd class="glossdef"><p>A variable, <code class="varname">$varname</code> is a lexically scoped
reference to a sequence of XDM items or an output port. The
distinction is not significant in everyday usage, pipeline authors can
always think of a variable as denoting a sequence of items. However,
from an implementation perspective, an output port variable represents
a connection in the graph to every step that references that variable.
An analysis of input bindings and output bindings may allow a
processor to build an entirely streaming implementation of (some)
pipelines that never need to reify output port variables.</p></dd><dt id="terminology.4.9" class="glossentry"><em class="glossterm">block expressions</em></dt><dd class="glossdef"><p>A block expression is an inlined expression that can perform
some relatively small amount of computation. It’s possible to describe
the XProc flow language without block expressions; every block
expression can be turned into a step that implements the expression.
But that would be very tedious in practice.
</p><div class="note admonition"><h3>Note</h3><p>The expression language inside the block expression is
imagined as a subset of XQuery 3.1. The exact nature of the subset is
still being discussed. The canonical expression is an
<code class="code">if</code>/<code class="code">then</code>/<code class="code">else</code> test.</p>
</div><p>Block expressions occupy the position of a step in a step chain,
consequently they may consume the outputs from the immediately
preceding step (if there is one), and they may produce outputs.</p><p>Within a block expression, the syntax of the output binding
operator is extended slightly. The outputs of the block expression are
referenced ordinally using an <span class="symbol">@</span>-sign;
<code class="code">≫ @1</code> writes to the first output, <code class="code">≫ @2</code> writes
to the second output, etc.</p></dd></dl></div>
</section>

<section id="understanding-xproc" class="section"><h2>3 Understanding XProc 2.0</h2>


<p>A flow is a description of the data flow graph. On the left and
right sides of a chain of steps, we use structuring and de-structuring
to assign ports to variables. The result is a variable that
(logically) denotes a sequence of items.</p>

<p>Steps have declarations but are not described otherwise within
the flow. An implementation can associate a step signature with an
implementation in their domain language by matching function
signatures.</p>

<p>Step invocations can be chained together by ordering them in a
sequence connected by the arrow operator (i.e., <span class="symbol">-&gt;</span> or
<span class="symbol">→</span> U+2192). A step chain must fully specify the input
port bindings along with any required options.</p>

<p>Let’s begin with an example pipeline. This is the “example 3”
pipeline from the XProc 1.0 specification.</p>

<figure id="understanding-xproc.6" class="example-wrapper"><div class="title">Example 1. An Example</div><div class="example"><pre class="programlisting line-numbers"><code>xproc version = "2.0"; <a name="ex-decl" id="ex-decl"></a><span data-number="1" class="callout-bug callout-bug-unicode">❶</span>

(: This example is from the XProc 1.0 specification (example 3). :)

 inputs $source as document-node(); <a name="ex-input" id="ex-input"></a><span data-number="2" class="callout-bug callout-bug-unicode">❷</span>
outputs $result as document-node(); <a name="ex-output" id="ex-output"></a><span data-number="3" class="callout-bug callout-bug-unicode">❸</span>

$source → { if (xs:decimal($1/*/@version) &lt; 2.0) <a name="ex-block" id="ex-block"></a><span data-number="4" class="callout-bug callout-bug-unicode">❹</span>
            then [$1,"v1schema.xsd"] → validate-with-xml-schema() ≫ @1 <a name="ex-at-1" id="ex-at-1"></a><span data-number="5" class="callout-bug callout-bug-unicode">❺</span>
            else [$1,"v2schema.xsd"] → validate-with-xml-schema() ≫ @1}
        → [$1,"stylesheet.xsl"] → xslt() <a name="ex-block-output" id="ex-block-output"></a><span data-number="6" class="callout-bug callout-bug-unicode">❻</span>
≫ $result <a name="ex-final-output" id="ex-final-output"></a><span data-number="7" class="callout-bug callout-bug-unicode">❼</span></code></pre></div></figure>

<div class="calloutlist"><dl><dt class="callout"><a href="#ex-decl"><span data-number="1" class="callout-bug callout-bug-unicode">❶</span></a> </dt><dd>
<p>The declaration that begins an XProc 2.0 pipeline
</p>
</dd><dt class="callout"><a href="#ex-input"><span data-number="2" class="callout-bug callout-bug-unicode">❷</span></a> </dt><dd>
<p>The pipeline inputs can be declared externally
</p>
</dd><dt class="callout"><a href="#ex-output"><span data-number="3" class="callout-bug callout-bug-unicode">❸</span></a> </dt><dd>
<p>So can the outputs
</p>
</dd><dt class="callout"><a href="#ex-block"><span data-number="4" class="callout-bug callout-bug-unicode">❹</span></a> </dt><dd>
<p>Inside this block <code class="varname">$1</code> refers to the first input, in this case
<code class="varname">$source</code>.
</p>
</dd><dt class="callout"><a href="#ex-at-1"><span data-number="5" class="callout-bug callout-bug-unicode">❺</span></a> </dt><dd>
<p>Using <code class="varname">@1</code> writes the validated result to the first
output of this block expression
</p>
</dd><dt class="callout"><a href="#ex-block-output"><span data-number="6" class="callout-bug callout-bug-unicode">❻</span></a> </dt><dd>
<p>The first (in this case only) output from the block expression
is used as the first input to the <code class="step">xslt</code> step.
</p>
</dd><dt class="callout"><a href="#ex-final-output"><span data-number="7" class="callout-bug callout-bug-unicode">❼</span></a> </dt><dd>
<p>The final output binding writes the result of the pipeline to
the <code class="varname">$result</code> output.
</p>
</dd></dl></div>
</section>

<section id="step-chains" class="section"><h2>4 Step Chains</h2>


<p>A step chain is a sequence of step invocations separated by the
chain operator (i.e., <span class="symbol">-&gt;</span> or <span class="symbol">→</span>
U+2192). On the left of the chain operator is always a preceding step
or input bindings. On the right must be a step invocation, a block
expression, or an optional output binding.
</p>

<p>The simplest input binding is a single expression that evaluates
to a sequence of one or more items. For example, the document(s) bound
to <code class="varname">$in</code> can be an input binding for the XInclude
step:</p>

<pre class="programlisting line-numbers"><code>$in → xinclude()</code></pre>

<p>If a step takes multiple inputs, the individual bindings must be
surrounded by square brackets:</p>

<pre class="programlisting line-numbers"><code>["document.xml", "style.xsl"] → xslt()</code></pre>

<p>In a binding with multiple inputs, the first input is bound to
the first input port (in declaration order), the second input to the
second port, etc. If necessary, or for clarity, a binding may be
preceded by a name assignment that explicitly names a port:</p>

<pre class="programlisting line-numbers"><code>[source="document.xml", stylesheet="style.xs"] → xslt()</code></pre>

<p>If positional and name references are mixed, all positional
references must precede the first named reference.</p>

<p>Steps produce some number of outputs on named ports. The outputs
of a step invocation immediately preceding the chain operator are
available as numbered inputs <code class="varname">$1</code>,
<code class="varname">$2</code>, etc. whose order is the order of the output
declarations on the step. For example, the <code class="step">xslt</code> step has
two output ports, <code class="output">result</code> and <code class="port">secondary</code>,
declared in that order. Following an <code class="step">xslt</code> step,
<code class="varname">$1</code> refers to the <code class="output">result</code> port and
<code class="varname">$2</code> refers to the <code class="port">secondary</code>
port.</p>

<pre class="programlisting line-numbers"><code>$in → xinclude() → [$1,"stylesheet.xsl"] → xslt()</code></pre>

<p>A reference to an ordinal port that does not exist produces an
empty sequence of documents.</p>

<div class="note admonition"><h3>Note</h3>
<p>This is an explicit relaxation of the rules in XProc 1.0 where
all bindings had to be composed statically, exactly, and perfectly. It
facilitates the use of block expressions where the number of outputs
may not always be the same. This explicitly relaxes the rule that all
of the outputs from a conditional must be identical.</p>
</div>

<div class="note admonition"><h3>Note</h3>
<p>It may be necessary to provide a function or other mechanism for
testing at runtime if a reference to <code class="varname">$3</code> (for
example) is empty because the third output port produced an empty
sequence or because there <em>was no</em> third output
port.</p>
</div>

<p>If two steps are connected together without an intervening input
binding, the implicit input binding is that the ports are connected
ordinally:</p>

<pre class="programlisting line-numbers"><code>→ [$1,$2,$3,…$n] →</code></pre>

<p>So this flow:</p>

<pre class="programlisting line-numbers"><code>$in → xinclude() → store("included.xml")</code></pre>

<p>is equivalent to this one:</p>

<pre class="programlisting line-numbers"><code>$in → xinclude() → [$1] → store("included.xml")</code></pre>
</section>

<section id="inputs" class="section"><h2>5 Inputs</h2>


<p>Inputs…</p>

<section id="uri-inputs" class="section"><h3>5.1 URI inputs</h3>


<p>A literal string in a port binding is a URI reference and the
resource identified by the URI will be loaded and bound to the
port.</p>

<pre class="programlisting line-numbers"><code>"doc.xml" → xinclude()</code></pre>

<p>An input can also be a sequence of documents using matching
parens:</p>

<pre class="programlisting line-numbers"><code>("d1.xml","d2.xml","d3.xml") → xinclude()</code></pre>

<p>Expressions and literals may be mixed to produce new sequences:</p>

<pre class="programlisting line-numbers"><code>($in,"doc.xml") → xinclude()</code></pre>

<p>Step inputs can be combined:</p>

<pre class="programlisting line-numbers"><code>[collection=($main,$secondary), query="query.xq"] → xquery()</code></pre>

<p>and can be used in more complex expressions:</p>

<pre class="programlisting line-numbers"><code>[$in,"stylesheet.xsl"] → xslt() → [($1,$2),"query.xq"] → xquery()</code></pre>
</section>

<section id="literal-inputs" class="section"><h3>5.2 Literal inputs</h3>


<p>A literal can be specified using a media-type specific data
constructor. For example, a data constructor may construct a JSON
object by include the object within the curly braces:</p>

<pre class="programlisting line-numbers"><code>data "application/json" {
   {
      name: "Alex",
      favoriteColor: "orange"
   }
}</code></pre>

<p>JSON array construction is also allowed:</p>

<pre class="programlisting line-numbers"><code>data "application/json" { [ 1,2,3,4] }</code></pre>

<p>An XML element may be constructed by embedding the literal
within the curly braces:</p>

<pre class="programlisting line-numbers"><code>data "application/xml" { &lt;doc&gt;&lt;title&gt;A test&lt;/title&gt;&lt;/doc&gt; }</code></pre>

<p>An HTML element can be similarly constructed:</p>

<pre class="programlisting line-numbers"><code>data "text/html" {
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;&lt;title&gt;Template&lt;/title&gt;
    &lt;link type="text/css" href="style.css"&gt;
    &lt;/head&gt;
    &lt;body&gt;…&lt;/body&gt;
    &lt;/html&gt;
}</code></pre>

<p>Text may also be directly embedded:</p>

<pre class="programlisting line-numbers"><code>data "text/plain" { "Now is the time for all good XProc …" }</code></pre>

<div class="note admonition"><h3>Note</h3>
<p>AVT expansion and curly brace escaping are unspecified here.</p>
</div>

<p>Processors are free to extend literal construction with the
constraint that the format can be unambiguously embedded within curly
braces.</p>
</section>
</section>

<section id="output-bindings" class="section"><h2>6 Output bindings</h2>


<p>The output binding operator (i.e., '&gt;&gt;' or
<code class="literal">≫</code> U+226B) takes a step chain or port variable
reference on the left hand side and binds the output to the right hand
side (i.e., a port variable reference, a URI reference, or an ordered
port ordinal.). The output binding operator is used to construct more
complex chains of data flows, store results, or write to output ports
for returning results.</p>

<p>The symbol “≫” is evocative of the “append” operation familiar
from many command-line systems. An output binding appends data to its
right hand side in the sense that it causes data to be sent there and
if several chains cause data to be sent to the same place, the effect
will be logical appending.</p>

<p>The identity assignment is performed by simply binding the input
to the output:</p>

<pre class="programlisting line-numbers"><code>$in ≫ $out</code></pre>

<p>The result is all the input on <code class="varname">$in</code> is sent to
the output port <code class="varname">$out</code> as it flows through the
graph.</p>

<p>A literal URI reference implies a document store:</p>

<pre class="programlisting line-numbers"><code>"doc.xml" → xinclude() ≫ "included.xml"</code></pre>

<p>In the case of implicit store, if the same output URI is used
more than once, the result of sending a sequence there is
implementation defined (e.g., the last document written).</p>

<p>If the outputs need to be referenced as inputs elsewhere, they
can be assigned to variables:</p>

<pre class="programlisting line-numbers"><code>$in → xinclude() ≫ $included
[$included,"schema.xsd"] → validate-with-xml-schema()
[$included,"stylesheet.xsl"] → xslt() ≫ [result=$out,secondary=$chunks]</code></pre>

<p>Variables assigned in this way can be used like any other
variable in expressions, but the implementation must enforce the
following semantics:</p>

<div class="orderedlist">



<ol style="list-style: decimal;"><li>
<p>Any reference to the variable must return all the documents
written by all of the step chains that write to that variable</p>
</li><li>
<p>All of the documents written by any single step chain must be
adjacent in the resulting sequence and must be in the order written by
the ultimate step in that chain.</p>
</li><li>
<p>Any referencial circularity raises a static error</p>
</li></ol></div>
<p>For example, the following has two documents flowing through
<code class="varname">$included</code>:</p>

<pre class="programlisting line-numbers"><code>"doc1.xml" → xinclude() ≫ $included
"doc2.xml" → xinclude() ≫ $included
$included → validate-with-xml-schema()</code></pre>

<p>The first two step chains are independent and the processor is
free to run them in either order, or in parallel. However, what is
passed to <code class="literal">validate-with-xml-schema()</code> when the
<code class="varname">$included</code> variable is referenced
<em>must</em> be all of the documents written by the first
chain followed by all of the documents written by the second, or vice
versa.</p>

<p>The names of output ports can be omitted in which case the
assignments are taken in declaration order. For example, the XSLT step
declares the <code class="output">result</code> port first and the
<code class="port">secondary</code> port second. An explicit set of
bindings:</p>

<pre class="programlisting line-numbers"><code>[source=$in,stylesheet="stylesheet.xsl"] → xslt() ≫ [result=$out,secondary=$chunks]</code></pre>

<p>can be shortened to:</p>

<pre class="programlisting line-numbers"><code>[$in,"stylesheet.xsl"] → xslt() ≫ [$out,$chunks]</code></pre>

<p>Within any context, every declared output port has an unnamed
ordinal. Some expressions (e.g. block expressions) have implicitly
declared output ports.</p>

<p>The ordinals can be referenced by name as <code class="literal">@1</code>,
<code class="literal">@2</code>, etc.</p>

<pre class="programlisting line-numbers"><code>$in → { if ($1/doc/cheese='cheddar')
        then consume() ≫ @1
        else reject() ≫ @1 }
     ≫ $out</code></pre>

</section>

<section id="step-declarations" class="section"><h2>7 Step Declarations and Invocations</h2>


<p>All steps are declared as external procedures with any number of
named inputs and outputs.</p>

<pre class="programlisting line-numbers"><code>step my:computation()
 inputs $source as document-node(),
outputs $result as xs:int*;</code></pre>

<p>Steps are always declared with qualified name. When they are are
invoked, a default namespace may be assumed by the processor.</p>

<p>Steps may have any number of options that can be optional and defaulted:</p>

<pre class="programlisting line-numbers"><code>step p:xslt(
  $initial-mode as xs:string ?,
  $template-name as xs:string?,
  $output-base-uri as xs:string?,
  $parameters as map()? = (),
  $version as xs:string = "2.0"
)
   inputs $source as document-node()+,
          $stylesheet as document-node()
   outputs $result as document-node()?,
           $secondary as document-node()*;</code></pre>

<p>All required options must be listed first in the declaration.</p>

<p>Options values are specified on invocation. Any unnamed option
values are matched in declaration order. Afterwards, all parameters
must be specified with a name.</p>

<p>For example:</p>

<pre class="programlisting line-numbers"><code>xslt("toc",$output-base-uri=base-uri($source))</code></pre>

<p>invokes the <code class="literal">xslt</code> step with the option value
"toc" for <code class="varname">$initial-mode</code> and explicitly named value
for <code class="varname">$output-base-uri</code> but does not specify a value
for <code class="varname">$template-name</code>. The value of
<code class="varname">$version</code> is defaulted to "2.0".</p>
</section>

<section id="block_expressions" class="section"><h2>8 Block Expressions</h2>


<p>A step chain may contain a block expression. A block expression
always has a ordinal set of inputs and outputs. The inputs are
assigned from the context of the expression in the chain. The outputs
are assigned based on the flow contained within the expression.</p>
<p>A block expression is enclosed within a set of curly brackets and
contains any number of step chains or other statements.</p>
</section>

<section id="conditionals" class="section"><h2>9 Conditionals</h2>


<p>A conditional may be placed within a step chain when surrounded
by curly brackets:</p>

<pre class="programlisting line-numbers"><code>$in → { if ($1/*/@version eq "v1.0")
        then [$1,"crummy.xsl"] → xslt() ≫ @1
        else [$1,"better.xsl"] → xslt() ≫ @1 }
    ≫ $out</code></pre>

<p>When the if/then expression is invoked, it acts as a guard on
the flows contained within the clause. Only one of the flows will
execute.</p>

<p>The outputs of the block are completely determined by the flows
executed. If they do not append any output to the ordinal outputs of
the block expression, the expression will not have any output. That
is, there is no implicit chaining of outputs.</p>

<div class="note admonition"><h3>Note</h3>
<p>What functions are available in the test conditional? Can I use
<code class="step">last</code> or <code class="step">position</code> for example?</p>
</div>
</section>

<section id="variables" class="section"><h2>10 Variables</h2>


<p>Within curly bracketed expressions, a let clause may be use to
assign variables to values:</p>

<pre class="programlisting line-numbers"><code>$in → {
   let $version := xs:int($1/*/@version) {
      if ($version &lt; 2)
      then [$1,"schema1.xsd"] → validate-with-xml-schema() ≫ @1
      else if ($version &lt; 3)
      then [$1,"schema2.xsd"] → validate-with-xml-schema() ≫ @1
      else fail("No schema available")
   }
} ≫ $out</code></pre>

<p>The variables share the same scope as port variable references but
cannot be used within append operators on the right side.</p>

<p>For example, this is not legal:</p>

<pre class="programlisting line-numbers"><code>$in → {
   let $dates := xs:dateTime($1/*/updated) {
     [$1,"schema1.xsd"] → validate-with-xml-schema() ≫ [@1,$dates]
   }
}</code></pre>

<p>but you can do this:</p>

<pre class="programlisting line-numbers"><code>$in → {
   let $dates := xs:dateTime($1/*/updated) {
     $dates &gt;&gt; @2
     [$1,"schema1.xsd"] → validate-with-xml-schema() ≫ @1
   }
}</code></pre>
</section>

<section id="projections" class="section"><h2>11 Projections</h2>


<p>A source can be turned into a sequence by an expression. The
result is a port that contains a sequence of items.</p>
<p>For example:</p>

<pre class="programlisting line-numbers"><code>$in//section → count() ≫ $out</code></pre>

<p>assigns the count of <code class="literal">section</code> element subtrees.</p>

<div class="note admonition"><h3>Note</h3>
<p>ndw: I still thinks it would be better to have a step that does
this; then there can be an xpath() step, a jsonpath() step, a csv()
step, etc. rather than building the semantics of projection into our
expression language.</p>
</div>
</section>

<section id="iteration" class="section"><h2>12 Iteration</h2>


<p>Iteration is a core operation and can be embedded within a step
chain with the <code class="literal">!</code> operator. For example:</p>

<pre class="programlisting line-numbers"><code>("d1.xml","d2.xml","d3.xml") ! { [$1,"schema.xsd"] → validate-with-xml-schema() ≫ @1}</code></pre>

<p>validates the three documents contained in the sequence.</p>

<p>The result of an iteration operation is a set of output bindings
where the first binding contains all of the documents written to
<code class="literal">@1</code>, the second all of the documents written to
<code class="literal">@2</code>, etc.</p>
</section>

<section id="replacement" class="section"><h2>13 Replacement</h2>

<div class="note admonition"><h3>Note</h3>
<p>formerly know as "viewports"</p>
</div>

<p>A portion of a document can be iterated over and replaced by an
embedded step chain. The <code class="literal">replace</code> operator requires
a single input, an expression, and a step chain body.</p>

<p>For each subtree matched, the block expression is run with the
subtree on the positional input port $1. The item on the positional
output port @1 will be its replacement.</p>

<p>It is an error if the block expression does not produce a
replacement.</p>

<div class="note admonition"><h3>Note</h3>
<p>ndw: I think this error is in conflict with our earlier rule that attempting to
read a port that wasn’t used returns the empty sequence. I think if step chain body
doesn’t write to <code class="literal">@1</code>, the replacement is simply the empty sequence.</p>
</div>

<p>For example:</p>

<pre class="programlisting line-numbers"><code>$in → replace (/doc/section) { [$1,"style.xsl"] → xslt() ≫ @1 } ≫ $out</code></pre>
<p>applies XSLT over a subtree.</p>
</section>

<section id="tee" class="section"><h2>14 Tee</h2>


<p>A chain can have an alternate flow embedded within the chain
using the tee operator (<code class="literal">tee</code> or
<code class="literal">⊤</code>). The flow must be a block expression. The
outputs following tee expression are exactly the same as if the tee
operator had been omitted.</p>

<p>In the following example, the result of the
<code class="step">xinclude</code> step is stored via an tee operator and that
result is also transformed by the <code class="step">xslt</code> step.</p>

<pre class="programlisting line-numbers"><code>$in → xinclude() ⊤ { $1 ≫ "included.xml" }
    → [$1,"stylesheet.xsl"] → xslt()
    ≫ $out</code></pre>
</section>

<section id="flow-declarations" class="section"><h2>15 Flow Declarations</h2>


<p>A flow can named and reused:</p>

<pre class="programlisting line-numbers"><code>flow my:process
   inputs $source as document-node(),
  outputs $result as document-node() {
    $source → xinclude() → [$1,"stylesheet.xsl"] → xslt() ≫ $result
 };</code></pre>
<pre class="programlisting line-numbers"><code>"doc.xml" → my:process() ≫ "doc.html"</code></pre>
</section>

<section id="xproc-modules" class="section"><h2>16 XProc Modules</h2>


<p>XProc modules are top-level containers for reuse. Every XProc
module must start with:</p>

<pre class="programlisting line-numbers"><code>xproc version = "2.0";</code></pre>

<p>A module consists of a version declaration (above), a set of
declarations, and a single optional unnamed flow description.</p>

<p>A module may end with a flow description. The inputs and outputs
of that port must be provided by the implementation when the module is
invoked.</p>

<p>A module may import other declarations via the import statement:</p>

<pre class="programlisting line-numbers"><code>import "library.xpl";</code></pre>

<p>A module may import declarations in the expression language:</p>

<pre class="programlisting line-numbers"><code>import "functions.xq";</code></pre>

<p>A module may also declare options as parameters to the module.</p>

<pre class="programlisting line-numbers"><code>option $user as xs:string;
option $passwd as xs:string;</code></pre>

<p>A must provide declarations for any undefined inputs and outputs
to the flow:</p>

<pre class="programlisting line-numbers"><code> inputs $source as document-node();
outputs $result as document-node();</code></pre>
</section>

<section id="grammar" class="appendix"><h2>A Grammar</h2>

<pre class="programlisting line-numbers"><code>XProc ::= XProcModule EOF

XProcModule ::= XProcVersionDecl? XProcProlog XProcFlow?
XProcVersionDecl ::= 'xproc' 'version' '=' StringLiteral XProcSeparator

XProcProlog   ::= ( ( XProcDefaultNamespaceDecl | XProcNamespaceDecl | XProcImport ) XProcSeparator )*
                  (XProcInputs XProcSeparator)?
                  (XProcOutputs XProcSeparator)?
                  (XProcOptionDecl XProcSeparator)*
                  (XProcStepDecl XProcSeparator)*

XProcImport ::= 'import' XProcURILiteral

XProcInputs ::= 'inputs' XProcParamList

XProcOutputs ::= 'outputs' XProcParamList

XProcOptionDecl ::= 'option' XProcParam

XProcStepDecl ::= 'step' FunctionName '(' XProcParamList? ')' XProcInputs? XProcOutputs?

XProcFlow ::= XProcFlowStatement+

XProcFlowStatement ::= ( XProcStepChain XProcOutputBinding? ) | XProcIfStatement | XProcLetStatement

XProcStepChain ::= (XProcSequenceLiteral XProcStepChainItem+) |
                   ((XProcStepInvocation | XProcBlockStatement) XProcStepChainItem*) 

XProcStepChainItem ::= XProcChainedItem | XProcIteratedItem | XProcTeedItem | XProcReplacedItem

XProcSequenceLiteral ::= XProcSequenceItem | '(' XProcSequenceItem ( ',' XProcSequenceItem )* ')'

XProcSequenceItem ::= XProcURILiteral | XProcPortInput

XProcChainedItem ::= XProcArrow XProcChainItem
XProcIteratedItem ::= XProcIteration XProcBlockStatement
XProcTeedItem ::= XProcTee XProcBlockStatement XProcChainedItem
XProcReplacedItem ::= XProcReplace '(' PathExpr ')' XProcBlockStatement

XProcChainItem ::=  XProcStepInvocation | XProcBlockStatement

XProcArrow ::= '=&gt;' | '→'

XProcIteration ::= '!'

XProcTee ::= 'tee' | '⊤'

XProcReplace ::= 'replace'

XProcInputPortList ::= '[' XProcInputPortBinding ( ',' XProcInputPortBinding )* ']'

XProcInputPortBinding ::= (QName '=')? XProcSequenceLiteral

XProcInputOrdinal ::= '$' IntegerLiteral

XProcOutputBinding ::= XProcAppend ( XProcOutputItem | XProcOutputPortList)

XProcAppend ::= '&gt;&gt;' | '≫'

XProcOutputItem ::= XProcURILiteral | XProcPortRef | XProcOutputOrdinal

XProcOutputOrdinal ::= '@' IntegerLiteral

XProcOutputPortList ::= '[' XProcOutputPortBinding ( ',' XProcOutputPortBinding) ']'

XProcOutputPortBinding ::= (QName '=')? XProcOutputItem

XProcPortInput ::= ( XProcPortRef | XProcInputOrdinal ) XProcProjection?

XProcPortRef ::= '$' QName 

XProcProjection ::= '/' ( RelativePathExpr / ) | '//' RelativePathExpr

XProcStepInvocation ::= (XProcInputPortList XProcArrow)? XProcStepName XProcArgumentList

XProcStepName ::= QName

XProcArgumentList ::= ArgumentList

XProcBlockStatement ::= '{' XProcFlow? '}'

XProcIfStatement ::= 'if' '(' ExprSingle ')' 'then' XProcFlowStatement 'else' XProcFlowStatement

XProcLetStatement ::= 'let' XProcLetBinding ( ',' XProcLetBinding )*  XProcLetBody

XProcLetBody ::= XProcBlockStatement

XProcLetBinding
         ::= '$' VarName XProcTypeDeclaration? ':=' ExprSingle

XProcNamespaceDecl
         ::= 'declare' 'namespace' NCName '=' XProcURILiteral
XProcDefaultNamespaceDecl
         ::= 'declare' 'default' 'namespace' XProcURILiteral

XProcParamList
         ::= XProcParam ( ',' XProcParam )*

XProcParam    ::= '$' QName XProcTypeDeclaration?

XProcTypeDeclaration ::= 'as' SequenceType

XProcSeparator ::= ';'

XProcURILiteral ::= StringLiteral



Expr     ::= ExprSingle ( ',' ExprSingle )*
ExprSingle ::= OrExpr

OrExpr   ::= AndExpr ( 'or' AndExpr )*
AndExpr  ::= ComparisonExpr ( 'and' ComparisonExpr )*
ComparisonExpr
         ::= StringConcatExpr ( ( ValueComp | GeneralComp | NodeComp ) StringConcatExpr )?
StringConcatExpr
         ::= RangeExpr ( '||' RangeExpr )*
RangeExpr
         ::= AdditiveExpr ( 'to' AdditiveExpr )?
AdditiveExpr
         ::= MultiplicativeExpr ( ( '+' | '-' ) MultiplicativeExpr )*
MultiplicativeExpr
         ::= UnionExpr ( ( '*' | 'div' | 'idiv' | 'mod' ) UnionExpr )*
UnionExpr
         ::= IntersectExceptExpr ( ( 'union' | '|' ) IntersectExceptExpr )*
IntersectExceptExpr
         ::= InstanceofExpr ( ( 'intersect' | 'except' ) InstanceofExpr )*
InstanceofExpr
         ::= TreatExpr ( 'instance' 'of' SequenceType )?
TreatExpr
         ::= CastableExpr ( 'treat' 'as' SequenceType )?
CastableExpr
         ::= CastExpr ( 'castable' 'as' SingleType )?
CastExpr ::= UnaryExpr ( 'cast' 'as' SingleType )?
UnaryExpr
         ::= ( '-' | '+' )* ValueExpr
ValueExpr
         ::= SimpleMapExpr
GeneralComp
         ::= '='
           | '!='
           | '&lt;'
           | '&lt;='
           | '&gt;'
           | '&gt;='
ValueComp
         ::= 'eq'
           | 'ne'
           | 'lt'
           | 'le'
           | 'gt'
           | 'ge'
NodeComp ::= 'is'
           | '&lt;&lt;'
           | '&gt;&gt;'
           
SimpleMapExpr
         ::= PathExpr ( '!' PathExpr )*
PathExpr ::= '/' ( RelativePathExpr / )
           | '//' RelativePathExpr
           | RelativePathExpr
RelativePathExpr
         ::= StepExpr ( ( '/' | '//' ) StepExpr )*
StepExpr ::= PostfixExpr
           | AxisStep
AxisStep ::= ( ReverseStep | ForwardStep ) PredicateList
ForwardStep
         ::= ForwardAxis NodeTest
           | AbbrevForwardStep
ForwardAxis
         ::= 'child' '::'
           | 'descendant' '::'
           | 'attribute' '::'
           | 'self' '::'
           | 'descendant-or-self' '::'
           | 'following-sibling' '::'
           | 'following' '::'
AbbrevForwardStep
         ::= '@'? NodeTest
ReverseStep
         ::= ReverseAxis NodeTest
           | AbbrevReverseStep
ReverseAxis
         ::= 'parent' '::'
           | 'ancestor' '::'
           | 'preceding-sibling' '::'
           | 'preceding' '::'
           | 'ancestor-or-self' '::'
AbbrevReverseStep
         ::= '..'
NodeTest ::= KindTest
           | NameTest
NameTest ::= EQName
           | Wildcard
PostfixExpr
         ::= PrimaryExpr ( Predicate | ArgumentList )*
ArgumentList
         ::= '(' ( Argument ( ',' Argument )* )? ')'
PredicateList
         ::= Predicate*
Predicate
         ::= '[' Expr ']'

PrimaryExpr
         ::= Literal
           | VarRef
           | XProcInputOrdinal
           | ParenthesizedExpr
           | ContextItemExpr
           | FunctionCall

ParenthesizedExpr
         ::= '(' Expr? ')'
ContextItemExpr
         ::= '.'

FunctionCall
         ::= FunctionName ArgumentList

Literal  ::= NumericLiteral
           | StringLiteral
NumericLiteral
         ::= IntegerLiteral
           | DecimalLiteral
           | DoubleLiteral
VarRef   ::= '$' VarName
VarName  ::= EQName

Argument ::= ExprSingle
           | ArgumentPlaceholder
ArgumentPlaceholder
         ::= '?'


EQName   ::= QName
           | URIQualifiedName

SingleType
         ::= SimpleTypeName '?'?
SequenceType
         ::= ItemType ( OccurrenceIndicator / )
OccurrenceIndicator
         ::= '?'
           | '*'
           | '+'
ItemType ::= KindTest
           | 'item' '(' ')'
           | MapTest
           | ArrayTest
           | AtomicOrUnionType
           | ParenthesizedItemType
AtomicOrUnionType
         ::= EQName

KindTest ::= DocumentTest
           | ElementTest
           | AttributeTest
           | PITest
           | CommentTest
           | TextTest
           | NamespaceNodeTest
           | AnyKindTest
AnyKindTest
         ::= 'node' '(' ')'
DocumentTest
         ::= 'document-node' '(' ElementTest? ')'
TextTest ::= 'text' '(' ')'
CommentTest
         ::= 'comment' '(' ')'
NamespaceNodeTest
         ::= 'namespace-node' '(' ')'
PITest   ::= 'processing-instruction' '(' ( NCName | StringLiteral )? ')'
AttributeTest
         ::= 'attribute' '(' ( AttribNameOrWildcard ( ',' TypeName )? )? ')'
AttribNameOrWildcard
         ::= AttributeName
           | '*'
ElementTest
         ::= 'element' '(' ( ElementNameOrWildcard ( ',' TypeName '?'? )? )? ')'
ElementNameOrWildcard
         ::= ElementName
           | '*'
AttributeName
         ::= EQName
ElementName
         ::= EQName
SimpleTypeName
         ::= TypeName
TypeName ::= EQName

MapTest  ::= AnyMapTest
           | TypedMapTest
AnyMapTest
         ::= 'map' '(' '*' ')'
TypedMapTest
         ::= 'map' '(' AtomicOrUnionType ',' SequenceType ')'
ArrayTest
         ::= AnyArrayTest
           | TypedArrayTest
AnyArrayTest
         ::= 'array' '(' '*' ')'
TypedArrayTest
         ::= 'array' '(' SequenceType ')'
ParenthesizedItemType
         ::= '(' ItemType ')'

QName    ::= FunctionName
           
FunctionName
         ::= QName^Token

NCName   ::= NCName^Token

Whitespace
    ::= S^WS | Comment
    /* ws: definition */

Comment
    ::= '(:' ( CommentContents | Comment )* ':)'
    /* ws: explicit */


IntegerLiteral
         ::= Digits
DecimalLiteral
         ::= '.' Digits
           | Digits '.' [0-9]*
          /* ws: explicit */
DoubleLiteral
         ::= ( '.' Digits | Digits ( '.' [0-9]* )? ) [eE] [+#x002D]? Digits
          /* ws: explicit */
StringLiteral
         ::= '"' ( PredefinedEntityRef | CharRef | EscapeQuot | [^"&amp;] )* '"'
           | "'" ( PredefinedEntityRef | CharRef | EscapeApos | [^'&amp;] )* "'"
          /* ws: explicit */
URIQualifiedName
         ::= BracedURILiteral NCName
          /* ws: explicit */
BracedURILiteral
         ::= 'Q' '{' ( PredefinedEntityRef | CharRef | [^&amp;{}] )* '}'
          /* ws: explicit */
PredefinedEntityRef
         ::= '&amp;' ( 'lt' | 'gt' | 'amp' | 'quot' | 'apos' ) ';'
          /* ws: explicit */
EscapeQuot
         ::= '""'
EscapeApos
         ::= "''"
NameStartChar
         ::= ':'
           | [A-Z]
           | '_'
           | [a-z]
           | [#x00C0-#x00D6]
           | [#x00D8-#x00F6]
           | [#x00F8-#x02FF]
           | [#x0370-#x037D]
           | [#x037F-#x1FFF]
           | [#x200C-#x200D]
           | [#x2070-#x218F]
           | [#x2C00-#x2FEF]
           | [#x3001-#xD7FF]
           | [#xF900-#xFDCF]
           | [#xFDF0-#xFFFD]
           | [#x10000-#xEFFFF]
NameChar ::= NameStartChar
           | '-'
           | '.'
           | [0-9]
           | #x00B7
           | [#x0300-#x036F]
           | [#x203F-#x2040]
Name     ::= NameStartChar NameChar*
CharRef  ::= '&amp;#' [0-9]+ ';'
           | '&amp;#x' [0-9a-fA-F]+ ';'
NCName   ::= Name - ( Char* ':' Char* )
QName    ::= PrefixedName
           | UnprefixedName
PrefixedName
         ::= Prefix ':' LocalPart
UnprefixedName
         ::= LocalPart
Prefix   ::= NCName
LocalPart
         ::= NCName
S        ::= ( #x0020 | #x0009 | #x000D | #x000A )+
Char     ::= #x0009
           | #x000A
           | #x000D
           | [#x0020-#xD7FF]
           | [#xE000-#xFFFD]
           | [#x10000-#x10FFFF]
Digits   ::= [0-9]+
CommentContents
         ::= ( ( Char+ - ( Char* ( '(:' | ':)' ) Char* ) ) - ( Char* '(' ) ) &amp;':'
           | ( Char+ - ( Char* ( '(:' | ':)' ) Char* ) ) &amp;'('
EOF      ::= $
Wildcard ::= '*'
           | NCName ':' '*'
           | '*' ':' NCName
           | BracedURILiteral '*'</code></pre>
</section>

</div><script src="prism.js"></script></body></html>